* diagrama DER - Diagrama Entidade Relacionamento
    --> Entidades: Retangulos (tabelas (ex: users))
    --> Atributos: Colunas (ex: id, first_name, last_name, email)
    --> PK: Chave primaria que nunca se repete
    --> FK: Chave estrangeira
    --> Relacionamento 1:1 | 1:N | N:N

  |                      USERS                            |

  |  id-     first_name-     last_name-     email-        |
  |  1       Jorge           Silvinha       jor@email.com |    
  |  2       Elson           Enfermeiro     els@email.com | 
  |  3       Rogerio         Costa          rog@email.com |  
  |  4       Rosalva         Silva          ros@email.com | 


 
  |                     PROFILES                          |

  |  id-     bio-            description-   FK user_id-   | 
  |  1       Sou Jorge       Lorem ipsum      1           |    
  |  2       Sou Elson       Lorem ipsum      2           | 
  |  3       Sou Rosalva     Lorem ipsum      4           |  


///////////////////////////////////////////////////////////////

* dbeaver:
  --> gerenciador de bancos de dados visual
  --> semelhante ao que o phpMyAdmin faz para MySQL /
  mas muito mais poderoso e compatível com dezenas de bancos

  ! interface visual para trabalhar com bancos de dados SQL



* linhas de codigo importantes:

    --> import sqlite3: 
        * Importa o módulo sqlite3, que permite /
        o Python se conectar e trabalhar com bancos de dados SQLite

        * sqlite: tipo de banco de dados leve e local armazenado em arquivo


    --> from pathlib import Path: 
        * importa a classe Path do módulo pathlib /
        que serve para trabalhar com caminhos de arquivos (manipulando)

    --> ROOT_DIR = Path(__file__).parent: 
        * Cria um objeto Path que representa o diretório onde /
        está o arquivo Python sendo executado.
        * __file__ : caminho do arquivo atual
        * .parent : pega a pasta onde o arquivo está

    --> DB_NAME = ...
        * define o nome do arquivo do banco de dados

    --> DB_FILE = ROOT_DIR / DB_NAME
        * Usa o operador / do Path (que junta caminhos) para criar /
        o caminho completo do arquivo do banco de dados dentro da pasta /
        do projeto
            --> Exemplo: C:\meuprojeto\db.sqlite3
      
    --> TABLE_NAME = ...
        * Define o nome da tabela

    --> connection = sqlite3.connect(DB_FILE):
        * Abre (ou cria, se não existir) o arquivo de banco de dados /
        SQLite indicado por DB_FILE.
        * O retorno é um objeto de conexão (connection) que permite /
         enviar comandos SQL ao banco.

    --> cursor = connection.cursor()
        * Cria um cursor, que é um objeto usado para executar /
        comandos SQL (como CREATE TABLE, INSERT, SELECT, etc.)




* infos: 
 
--------------------------------------------------------
CUIDADO: delete sem where apaga tudo da tabela !

cursor.execute(
    f'''
    DELETE FROM {TABLE_NAME}
    '''
)
connection.commit()

--------------------------------------------------------
RECOMEÇAR SEQUENCIA: tem que apagar tudo antes

cursor.execute(
    f'''
    DELETE FROM sqlite_sequence WHERE name="{TABLE_NAME}"
    '''
)
connection.commit()

--------------------------------------------------------
* execute: um valor []
* executemany: varios valores [[]]
* usar tupla pois evita alterações acidentais ou maliciosas (imutavel)
* LIMIT (numero): limita a quantidade de itens da tabela no select
* felchall = pega todos os dados de um pesquisa SQL (for row in rows)
* fetchone = pega apenas um registro (print(row))
* WHERE: filtra a busca (id= "2": procura o item com o id 2)
* CAST: utilizado para converter um dado 
       - (CAST ... AS INTEGER)
       - (SLECT CAST('2011' AS INTEGER))
* substr: é usada para pegar apenas uma parte de uma string.
       - CAST(substr(RELEASE_DATE, 7, 4) AS INTEGER) ASC
* if __name__ == '__main__': Serve para executar um bloco de código apenas /
quando o arquivo é executado diretamente, e não quando ele é importado